## 如何使用 hevm 作弊码测试依赖于 ecrecover 签名的代码

## 介绍
EIP 2612 向 ERC20 abi 引入了函数 `permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)`。 该函数本质上是通过ECDSA结合EIP 712标准对类型化数据散列接收签名参数，并通过`ecrecover()`恢复签名的作者。 然后它将`allowances[owner][spender]`设置为value。 

## 使用
这是一种分配allowances的新方法，因为签名可以在链下计算并传递给合约。 这允许中继者支付许可交易的全部 Gas 费用以换取费用，从而允许用户进行完全无 Gas 的交易。 此外，这消除了典型的`approve() -> transferFrom()` 模式，该模式强制用户通过这种新方法发送两个事务而不是一个事务。

请注意，要使许可功能起作用，需要有效的签名。 这个例子将展示我们如何使用 [hevm 的签名作弊码](https://github.com/dapphub/dapptools/blob/master/src/hevm/README.md#cheat-codes)使用私钥对数据进行签名。 更一般地说，你可以使用这个作弊码来测试任何需要有效签名的东西。

## 例子
我们使用 solmate 实现的 ERC20 标准，其中包括许可功能。 请注意，`PERMIT_TYPEHASH` 和`mapping(address -> uint256) public nonces`也有值，前者是 EIP712 标准的一部分，后者用于防止签名重放攻击。

在我们的 `TestDepositWithPermit` 合约中，我们需要由所有者签署签名以进行验证。 为此，我们可以使用 hevm 的签名作弊码，它接收一条消息和一个私钥并创建一个有效的签名。 对于本例，我们使用私钥 0x02 和以下签名消息，它本质上表示 EIP 712 之后的许可签名：

```
keccak256(
    abi.encodePacked(
        "\x19\x01",
        asset.DOMAIN_SEPARATOR(),
        keccak256(
            abi.encode(
                keccak256(
                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
                ),
                owner,
                spender,
                assetAmount,
                asset.nonces(owner),
                block.timestamp
            )
        )
    )
);
```
辅助函数 `getSignature(address owner, address spender, uint256 assetAmount)` 返回通过签名作弊码生成的有效签名。 请注意，签名作弊码会泄漏私钥，因此在测试时最好使用虚拟密钥。 我们的密钥对数据取自[该站点](https://privatekeys.pw/keys/ethereum/1)。 现在为了测试签名，我们将随机数铸币到 `OWNER` 地址，该地址对应于私钥 `0x02`，它是许可签名的签名者。 然后我们看看是否可以使用该签名将所有者的代币转移给我们自己。

首先，我们将使用在 `getSignature()` 中生成的签名在我们的 Mock ERC20 令牌上调用 `permit()`，然后调用 `transferFrom()`。 如果我们的许可请求和转移成功，我们的模拟 ERC20 余额应该增加允许的金额，而 `OWNER` 的余额也应该减少。 为简单起见，我们将转移所有铸造的代币，以便 `OWNER` 的余额应为 `0`，而我们的余额应为`amount`。

## Code
完整的示例代码可以在[这里](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/TestDepositWithPermit.sol)找到。