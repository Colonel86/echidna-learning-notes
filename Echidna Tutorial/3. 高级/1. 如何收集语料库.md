## 介绍
我们将看到如何收集和使用 Echidna 的交易语料库。 目标是以下智能合约（[example/magic.sol](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/magic.sol)）：
```
contract C {
  bool value_found = false;
  function magic(uint magic_1, uint magic_2, uint magic_3, uint magic_4) public {
    require(magic_1 == 42);
    require(magic_2 == 129);
    require(magic_3 == magic_4+333);
    value_found = true;
    return;
  }

  function echidna_magic_values() public returns (bool) {
    return !value_found;
  }

}
```
这个小例子迫使 Echidna 找到某些值来更改状态变量。 这对于 fuzzer 来说很难（推荐使用像 Manticore 这样的符号执行工具）。 我们可以运行 Echidna 来验证这一点：
```
$ echidna-test magic.sol 
...

echidna_magic_values: passed! 🎉

Seed: 2221503356319272685
```
但是，在运行这个 fuzzing 活动时，我们仍然可以使用 Echidna 来收集语料库。
## 收集语料库
要启用语料库集合，请创建语料库目录：
```
mkdir corpus-magic
```
还有一个 Echidna 配置文件 config.yaml：
```
corpusDir: "corpus-magic"
```
现在我们可以运行我们的工具并检查收集的语料库：
```
echidna-test magic.sol --config config.yaml
```
Echidna仍然找不到正确的magic value。 我们可以通过查看 corpus-magic/covered.*.txt 文件来验证它卡在哪里：
```
r   |contract C {
  bool value_found = false;
r   |  function magic(uint magic_1, uint magic_2, uint magic_3, uint magic_4) public {
r   |    require(magic_1 == 42);
r   |    require(magic_2 == 129);
r   |    require(magic_3 == magic_4+333);
    value_found = true;
    return;
  }

  function echidna_magic_values() public returns (bool) {
    return !value_found;
  }

}
```
每行左侧的标签 `r` 表明 Echidna 能够到达这些行，但它以还原结束。 如您所见，模糊器在最后一个`require`处卡住了。

要找到解决方法，让我们看一下它收集的语料库。 例如，这些文件之一是：
```
[
   {
      "_gas'" : "0xffffffff",
      "_delay" : [
         "0x13647",
         "0xccf6"
      ],
      "_src" : "00a329c0648769a73afac7f9381e08fb43dbea70",
      "_dst" : "00a329c0648769a73afac7f9381e08fb43dbea72",
      "_value" : "0x0",
      "_call" : {
         "tag" : "SolCall",
         "contents" : [
            "magic",
            [
               {
                  "contents" : [
                     256,
                     "93723985220345906694500679277863898678726808528711107336895287282192244575836"
                  ],
                  "tag" : "AbiUInt"
               },
               {
                  "contents" : [
                     256,
                     "334"
                  ],
                  "tag" : "AbiUInt"
               },
               {
                  "contents" : [
                     256,
                     "68093943901352437066264791224433559271778087297543421781073458233697135179558"
                  ],
                  "tag" : "AbiUInt"
               },
               {
                  "tag" : "AbiUInt",
                  "contents" : [
                     256,
                     "332"
                  ]
               }
            ]
         ]
      },
      "_gasprice'" : "0xa904461f1"
   }
]
```
显然，这个输入不会触发我们property的失败。 在下一步中，我们将看到如何为此进行修改。

## 播种语料库
Echidna需要一些帮助来处理`magic`功能。 我们将复制和修改输入以使用合适的参数：
```
cp corpus-magic/coverage/2712688662897926208.txt corpus-magic/coverage/new.txt
```
我们将修改 new.txt 以调用 magic(42,129,333,0)。 现在，我们可以重新运行 Echidna：
```
$ echidna-test magic.sol --config config.yaml 
...
echidna_magic_values: failed!💥  
  Call sequence:
    magic(42,129,333,0)


Unique instructions: 142
Unique codehashes: 1
Seed: -7293830866560616537
```
这一次，财产立即受到侵犯。 我们可以验证是否创建了另一个被覆盖的.*.txt 文件，其中显示了 Echidna 执行的另一个跟踪（标有 *），该跟踪在magic函数结束时以 return 结束。
```
*r  |contract C {
  bool value_found = false;
*r  |  function magic(uint magic_1, uint magic_2, uint magic_3, uint magic_4) public {
*r  |    require(magic_1 == 42);
*r  |    require(magic_2 == 129);
*r  |    require(magic_3 == magic_4+333);
*   |    value_found = true;
    return;
  }

  function echidna_magic_values() public returns (bool) {
    return !value_found;
  }
}
```