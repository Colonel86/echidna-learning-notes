以下描述了使 Echidna 更高效的模糊测试技巧：

- 要过滤输入的值范围，请使用 %。 请参阅 [Filtering inputs](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/fuzzing_tips.md#filtering_inputs)。
- 当需要动态数组时，使用 push/pop。 请参阅[Dealing with dynamic arrays](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/fuzzing_tips.md#dealing_with_dynamic_arrays)。

## Filtering inputs
要过滤输入，% 比添加 require 或 if 语句更有效。 例如，如果您正在对 index 应该小于 10**18 的操作（uint256 index, ..）进行模糊测试，请使用：
```
function operation(uint index, ...) public{
   index = index % 10**18
   ...
}
```
如果改为使用 require(index <= 10**18) ，则生成的许多事务将恢复，从而减慢 fuzzer。

这也可以概括定义一个最小和最大范围，例如：
```
function operation(uint balance, ...) public{
   balance = MIN_BALANCE + balance % (MAX_BALANCE - MIN_BALANCE);
   ...
}
```
将确保余额始终在 MIN_BALANCE 和 MAX_BALANCE 之间，而不会丢弃任何生成的交易。 正如预期的那样，这将加快探索速度，但代价是避免代码中的某些路径。 为了克服这个问题，通常的解决方案是具有两个功能：
```
function operation(uint balance, ...) public{
   ... // original code
}

function safeOperation(uint balance, ...) public{
   balance = MIN_BALANCE + balance % (MAX_BALANCE - MIN_BALANCE); // safe balance
   ...
}
```
因此，Echidna 可以免费使用其中的任何一种，探索输入数据的安全和不安全使用。
## 处理动态数组
当使用动态数组作为输入时，Echidna 会将其大小限制为 32 个元素：
```
function operation(uint256[] data, ...) public{
   ... // use of data
}
```
这是因为反序列化动态数组很慢，并且在执行过程中会占用一些内存。 动态数组也有问题，因为它们很难变异。 尽管如此，Echidna 包含一些特定的变异器来删除/重复元素或剪切元素。 这些突变器是使用收集的语料库执行的。 一般来说，我们建议使用 `push(..)` 和 `pop()` 函数来处理用作输入的动态数组的探索：
```
private uint256[] data;
function push(uint256 x) public{
   data.push(x);
}

function pop() public{
   data.pop();
}

function operation(...) public{
   ... // use of data
}
```
这可以很好地测试具有少量元素的数组； 但是，它在探索中引入了一个意想不到的偏差：由于 push 和 pop 是将以相等概率被选择的函数，因此构建大型数组（例如超过 64 个元素）的机会非常非常小。 一种快速的解决方案可能是在短期活动期间将 pop() 函数列入黑名单：
```
filterFunctions: ["C.pop()"]
```
这对于小规模测试来说已经足够了。 使用称为[swarm testing](https://www.cs.utah.edu/~regehr/papers/swarm12.pdf)的特定测试技术可以获得更通用的解决方案。 这允许使用一些工具运行长时间的测试活动，但随机改组它的配置。 在 Echidna 的情况下，群测试使用不同的配置文件运行，它在测试之前将合约中的一些随机函数列入黑名单。 我们使用 [echidna-parade](https://github.com/crytic/echidna-parade) 提供群体测试和可扩展性，这是我们用于模糊智能合约的专用工具。 [此处](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/smart-contract-fuzzing-at-scale.md)提供了使用 echidna-parade 的特定教程。

