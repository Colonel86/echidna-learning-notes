## 使用 Echidna 进行端到端测试
当智能合约需要复杂的初始化并且时间很短时，我们希望避免手动重新创建部署以使用 Echidna 进行fuzzing。 这就是为什么我们有一种使用 Echidna 进行测试的新方法，该方法基于直接从 ganache 部署和执行测试。

## 要求：
这种方法需要一个智能合约项目，具有以下约束：

- 它应该使用 Solidity：不支持 Vyper，因为 Slither/Echidna 在运行这些方面不是很有效（例如，不包括 AST）。
- 它应该有测试，或者至少有一个完整的部署脚本。
- 它应该与 Slither 一起使用。 如果失败，请报告问题。
在本教程中，我们使用了[drizzle-box example](https://github.com/truffle-box/drizzle-box)。

## 入门：
在说明之前，请确保您已安装 Echidna 和 Etheno 的最新版本。

然后，安装包来编译项目：
```
$ git clone https://github.com/truffle-box/drizzle-box
$ cd drizzle-box
$ npm i truffle
```

如果未安装 ganache，请手动添加。 在我们的示例中，我们将运行：
```
$ npm i ganache
```
其他使用 yarn 的项目需要：
```
yarn add ganache
```
确保 `$ ganache --version` 输出 ganache `v7.3.2` 或更高版本。

从可用测试中选择一个测试脚本也很重要。 理想情况下，该测试将部署所有（或大多数）合约，包括模拟/测试合约。 对于这个例子，我们将看一下 SimpleStorage 合约：
```
contract SimpleStorage {
    event StorageSet(string _message);

    uint256 public storedData;

    function set(uint256 x) public {
        storedData = x;

        emit StorageSet("Data stored successfully!");
    }
}
```
这个小合约允许设置 storedData 状态变量。 正如预期的那样，我们有一个单元测试来部署和测试这个合约（simplestorage.js）：
```
const SimpleStorage = artifacts.require("SimpleStorage");

contract("SimpleStorage", accounts => {
  it("...should store the value 89.", async () => {
    const simpleStorageInstance = await SimpleStorage.deployed();

    // Set value of 89
    await simpleStorageInstance.set(89, { from: accounts[0] });

    // Get stored value
    const storedData = await simpleStorageInstance.storedData.call();

    assert.equal(storedData, 89, "The value 89 was not stored.");
  });
});
```
## 捕获交易
在开始编写有趣的属性之前，有必要收集一个 Etheno 跟踪以在 Echidna 中重放它：

首先，启动 Etheno：
```
etheno --ganache --ganache-args="--miner.blockGasLimit 10000000" -x init.json
```
默认情况下，以下 Ganache 参数是通过 Etheno 设置的：

- `-d`：Ganache 将使用预定义的确定性种子来创建所有帐户。
- `--chain.allowUnlimitedContractSize`：在调试时允许无限的合约大小。 这样设置是为了对要部署的合约没有大小限制
- `-p <port_num>`：`port_num` 将设置为 
    (1) --ganache-port 的值或 
    (2) Etheno 将选择比运行 Etheno 的 JSON RPC 服务器的端口号高的最小端口号。

注意：如果你使用 Docker 运行 etheno，命令应该是：
```
$ docker run -it -p 8545:8545 -v ~/etheno:/home/etheno/ trailofbits/etheno
(you will now be working within the Docker instance)
$ etheno --ganache --ganache-args="--miner.blockGasLimit 10000000" -x init.json
```

- 第一个命令中的 `-p` 将 Docker 容器内部的端口 8545 发布（即公开）到主机上的端口 8545。
- 第一个命令中的 `-v` 将 Docker 容器内部的目录映射到 Docker 容器外部的目录。 Etheno 退出后，`init.json` 文件现在将位于主机上的 `~/etheno` 文件夹中。

请注意，如果部署由于`ProviderError: exceeds block gas limit`异常而无法成功完成，增加 `--miner.blockGasLimit` 值会有所帮助。 这对于大型合约部署特别有用。 单击[此处](https://www.npmjs.com/package/ganache)了解有关可以设置的各种 Ganache 命令行参数的更多信息。

此外，如果 Etheno 未能产生任何输出，则它无法在后台执行 `ganache`。 检查是否可以在不使用 Etheno 的情况下从终端正确执行 `ganache`（带有相关的命令行参数）。

同时，在另一个终端中，运行一个测试或部署过程。 如何运行它取决于项目是如何开发的。 例如，对于truffle，使用：
```
$ truffle test test/test.js
```
对于建设者:
```
buidler test test/test.js --network localhost
```
在 Drizzle 示例中，我们将运行：
```
truffle test test/simplestorage.js --network develop
```
Etheno 完成后，使用 Ctrl+c（或 Mac 上的 Command+C）轻轻地杀死它。 它将保存 `init.json` 文件。 如果您的测试由于某种原因失败或者您想运行另一个测试，请重新启动 Etheno 并重新运行测试。

## 编写和运行属性
一旦我们有了一个保存交易的 json 文件，我们就可以验证 `SimpleStorage` 合约部署在 `0x871DD7C2B4b25E1Aa18728e9D5f2Af4C4e431f5c`，因此我们可以轻松地编写一个带有简单属性的合约（`./contracts/crytic/E2E.sol`）来测试它：
```
import "../SimpleStorage.sol";

contract E2E {
        SimpleStorage st = SimpleStorage(0x871DD7C2B4b25E1Aa18728e9D5f2Af4C4e431f5c);
        function crytic_const_storage() public returns(bool) {
            return st.storedData() == 89;
        }
}
```

这个简单的属性检查存储的数据是否保持不变。 要运行它，您将需要以下针鼹配置文件 (`echidna.yaml`)：
```
prefix: crytic_
initialize: init.json
multi-abi: true
cryticArgs: ['--truffle-build-directory', 'app/src/contracts/'] # needed by drizzle
```
然后，运行 Echidna 立即显示结果：
```
$ echidna-test . --contract E2E --config echidna.yaml
...
crytic_const_storage: failed!💥  
  Call sequence:
    (0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c).set(0) from: 0x0000000000000000000000000000000000010000
```
对于这最后一步，请确保您使用的是 `.` 作为`echidna-test`的目标。 如果您改用 `E2E.sol` 文件的路径，那么 Echidna 将无法从所有已部署的合约中获取信息来调用 `set(uint256)` 函数，并且该属性将永远不会失败。

## 主要考虑因素：
将 Etheno 与 Echidna 一起使用时，请注意有两种极端情况可能会导致意外行为：

- 使用 ether 的函数调用：在 Ganache 中创建和用于测试的帐户与在 Echidna 中用于发送交易的帐户不同。 因此，Ganache 账户的账户余额不会结转到 Echidna 使用的账户。 因此，如果 Etheno 记录的函数调用需要从 Ganache 中存在的帐户转移一些以太币，则此调用将在 Echidna 中失败。
- 依赖 block.timestamp 的Fuzz：Ganache 和 Echidna 的时间概念不同。 Echidna 总是以固定的时间戳开始，而 Etheno 将使用 Ganache 的时间概念。 这意味着依赖时间戳比较/评估的fuzz测试中的断言或要求可能会在 Echidna 中失败。
  
在本教程的下一部分中，我们将探索如何使用基于 Slither 的特定工具轻松找到合约的部署位置。 如果部署过程很复杂并且我们需要测试特定的合约，这将很有用。