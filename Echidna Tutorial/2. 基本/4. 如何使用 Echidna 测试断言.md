## Introduction
在这个简短的教程中，我们将向您展示如何使用 Echidna 检查智能合约中的assertions。 对于此示例，请确保您使用 Solidity 0.7.x 或更早版本。 如果您使用 Solidity 0.8.x 运行它们，测试将永远不会失败。

## Write an assertion
假设我们有这样一份合同：
```
contract Incrementor {
  uint private counter = 2**200;

  function inc(uint val) public returns (uint){
    uint tmp = counter;
    counter += val;
    // tmp <= counter
    return (counter - tmp);
  }
}
```
我们要确保 tmp 在返回其差值后小于或等于 counter。 我们可以编写 Echidna property，但我们需要将 tmp 值存储在某个地方。 相反，我们可以使用这样的断言（[example/assert.sol](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/assert.sol)）：
```
contract Incrementor {
  uint private counter = 2**200;

  function inc(uint val) public returns (uint){
    uint tmp = counter;
    counter += val;
    assert (tmp <= counter);
    return (counter - tmp);
  }
}
```
我们还可以使用带有任意数量参数的称为 `AssertionFailed` 的特殊事件来让 Echidna 知道断言失败，而无需使用`assert`。 这适用于任何合同。 例如：
```
contract Incrementor {
  event AssertionFailed(uint);
  uint private counter = 2**200;

  function inc(uint val) public returns (uint){
    uint tmp = counter;
    counter += val;
    if (tmp > counter)
      emit AssertionFailed(counter);
    return (counter - tmp);
  }
}
```
## Run Echidna
要在 Echidna 中启用断言失败测试，您可以直接从命令行使用 `--test-mode assertion`。

否则，您可以创建一个 [Echidna 配置文件](https://github.com/crytic/echidna/wiki/Config) `config.yaml`，并设置 testMode 用于断言检查：
```
testMode: assertion
```
当我们与 Echidna 运行这个合约时，我们得到了预期的结果：
```
$ echidna-test assert.sol --test-mode assertion
Analyzing contract: assert.sol:Incrementor
assertion in inc: failed!💥  
  Call sequence, shrinking (2596/5000):
    inc(21711016731996786641919559689128982722488122124807605757398297001483711807488)
    inc(7237005577332262213973186563042994240829374041602535252466099000494570602496)
    inc(86844066927987146567678238756515930889952488499230423029593188005934847229952)

Seed: 1806480648350826486
```
如您所见，Echidna 在 `inc` 函数中报告了一个断言失败。 可以为每个函数添加多个断言，但是，Echidna 无法判断哪个断言失败。

## When and how to use assertions
如果要检查的条件与某些操作 `f` 的正确使用直接相关，则断言可以用作显式属性的替代方案。 在某些代码之后添加断言将强制检查在执行后立即发生：
```
function f(..) public {
    // some complex code
    ...
    assert (condition);
    ...
}
```
相反，使用显式布尔属性将随机执行事务，并且没有简单的方法来准确执行何时检查。 仍然可以执行此解决方法：
```
function echidna_assert_after_f() public returns (bool) {
    f(..); 
    return(condition);
}
```
但是，有一些问题：
- 如果 `f` 声明为internal或external，则不会编译
- 尚不清楚应该使用哪些参数来调用 `f`
- 如果 `f` reverts，该属性将失败

Assertions可以帮助克服这个可能的问题。 例如，在调用 internal or public 函数时可以很容易地检测到它们：
```
function f(..) public {
    // some complex code
    ...
    g(..) // this contains an assert
    ...
}
```
如果 `g` 是external的，那么断言失败只能在 Solidity 0.8.x 或更高版本中检测到。

一般来说，我们建议遵循 [John Regehr](https://blog.regehr.org/archives/1091) 关于使用断言的建议：

- 在断言检查期间不要强制产生任何副作用。 例如：assert(ChangeStateAndReturn() == 1)
- 不要断言明显的陈述。 例如 assert(var >= 0) 其中 var 被声明为 uint。
  
最后，请不要使用 require 替换 assert，因为 Echidna 将无法检测到它（但无论如何合同都会revert）。

## Summary: Assertion Checking
下面总结了 Echidna 在我们的示例中的运行情况（请记住使用 0.7.x 或更早版本）：
```
contract Incrementor {
  uint private counter = 2**200;

  function inc(uint val) public returns (uint){
    uint tmp = counter;
    counter += val;
    assert (tmp <= counter);
    return (counter - tmp);
  }
}
```

```
$ echidna-test assert.sol --test-mode assertion
Analyzing contract: assert.sol:Incrementor
assertion in inc: failed!💥  
  Call sequence, shrinking (2596/5000):
    inc(21711016731996786641919559689128982722488122124807605757398297001483711807488)
    inc(7237005577332262213973186563042994240829374041602535252466099000494570602496)
    inc(86844066927987146567678238756515930889952488499230423029593188005934847229952)

Seed: 1806480648350826486
```
Echidna 发现，如果使用大参数多次调用此函数，则 `inc` 中的断言可能会失败。