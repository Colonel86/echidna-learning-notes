# 常见的测试方法
测试智能合约并不像测试在本地计算机上运行的普通二进制文件那么简单。 这是由于存在与一个或多个入口点交互的多个帐户造成的。 虽然 fuzzer 可以模拟以太坊虚拟机并可能使用具有任何功能的任何帐户（例如无限数量的 ETH），但我们注意避免破坏以太坊中不可能的交易的一些重要潜在假设（例如，使用 msg.sender 作为零地址）。 这就是为什么清楚地了解要测试的系统以及如何模拟交易是很重要的。 测试方法有几个分类。 我们将从internal 和 external的两个开始：

## Internal testing
在这种测试方法中，测试在合约内部定义的属性，这种方法可以完全访问系统的内部状态。
```
Contract InternalTest is System { 
    function echidna_state_greater_than_X() public returns (bool) {
       return stateVar > X;
    }
}
```
在这种方法中，Echidna 将生成从模拟账户到目标合约的交易。 这种测试方法对于不需要复杂初始化并且具有单个入口点的简单合约特别有用。 此外，properties可以更容易编写，因为properties可以访问系统的内部状态。

## External testing
```
contract ExternalTest {
    constructor() public {
       addr = address(0x...);
    }
    function echidna_state_greater_than_X() public returns (bool) {
       return System(addr).stateVar() > X;
    }
}
```
这种测试方法对于处理需要外部初始化的合约（例如使用 Etheno）很有用，但是，它应该正确处理 Echidna 如何运行交易，因为具有属性的合约不再与我们要测试的合约相同。 由于 ExternalTest 没有定义额外的方法，因此直接在其上运行 Echidna 将不允许从合约执行任何代码进行测试（ExternalTest 中除了实际属性之外没有可以调用的函数）。 在这种情况下，有几种选择：

**Contract wrapper**：定义特定操作来“wrap”要测试的系统。 对于我们希望 Echidna 在系统中执行以进行测试的每个操作，我们添加一个或多个在其外部执行的功能。

```
contract ExternalTest {
    constructor() public {
       addr = ..;
    }

    function method(...) public returns (...) {
       return System(addr).method(..);
    }

    function echidna_state_greater_than_X() public returns (bool) {
       return System(addr).stateVar() > X;
    }
}
```
在这种方法中需要考虑两个重要点：
- 每笔交易的发送者将是 ExternalTest 合约，而不是模拟的 Echidna 发送者（例如 0x10000，..）。 这意味着与系统交互的真实地址将是外部合约之一，而不是 Echidna 发送者之一。 如果您需要在本合约中提供 ETH 或代币，请特别小心。
- 这种方法是手动的，如果有很多函数操作可能会很耗时，但是当 Echidna 需要一些帮助来计算一些不能随机采样的值时，它会很有用：
```
contract ExternalTest {
    ...
    function methodUsingF(..., uint256 x) public returns (...) {
       return System(addr).method(.., f(x));
    }
    ... 
}
```
**Multi ABI**：如果启用了`multi-abi`模式，Echidna 能够直接调用每个合约。 这意味着使用它不需要包装调用，但是由于可以调用每个部署的合约，因此可能会产生意想不到的影响。 例如，如果我们有一个属性来确保令牌的数量是有限的：
```
contract ExternalTest {
    constructor() public {
       addr = ..;
       MockERC20(..).mint(..);  
    }

    function echidna_limited_supply() public returns (bool) {
       return System(addr).balanceOf(...) <= X;
    }
    ... 
}
```
如果我们对代币使用“mock”合约（例如 MockERC20）可能是一个问题，因为 Echidna 可以调用公共但只应该在初始化期间使用的函数，例如 mint。 使用要忽略的功能黑名单可以轻松解决此问题：
```
filterBlacklist: true
filterFunctions: [“MockERC20.mint(uint256,address)”]
```
最后，使用这种方法还有另一个好处：它将迫使开发人员或审计员使用公共数据编写属性。 如果无法使用公共数据定义重要属性，则可能表明用户或其他合约将无法轻松与系统交互以执行某些操作或验证系统处于有效状态。

## Partial testing
理想情况下，测试智能合约系统使用完整的部署系统，该部署系统具有开发人员打算使用的相同参数。 使用真实代码进行测试，总是首选，即使它比做其他事情要慢（但也许不是在它非常慢的情况下）。 但是，在很多情况下，即使部署了完整的系统，也无法模拟，因为它依赖于链下组件（例如token bridge）。 在这种情况下，我们被迫实施替代解决方案。

在这种情况下，我们将对一些组件进行测试，忽略或抽象出不感兴趣的部分，例如标准 ERC20 代币或oracles。 有几种方法可以做到这一点。

**Isolated testing**：如果一个组件从系统的其余部分中适当地抽象出来，那么测试它就很容易。 ==这对于测试可以在计算数学运算的组件中找到的无状态属性特别有用==，例如数学库。

**Function override**：Solidity 允许覆盖函数，以更改一段代码的功能，而不影响代码库的其余部分。 我们可以使用它来禁用我们测试中的某些功能，以便允许使用 Echidna 进行测试：

```
Contract InternalTestOverridingSignatures is System {

    function verifySignature(..) public returns (bool) override {
      return true; // signatures are always valid
    }
 
    function echidna_state_greater_than_X() public returns (bool) {
       executeSomethingWithSignature(..)
       return stateVar > X;
    }
}
```
**Model testing**：如果系统不够模块化，那么我们将需要一种不同的方法。 我们将在 Solidity 中创建系统的“model”，而不是按原样使用代码，主要使用原始代码。 虽然没有定义构建模型的步骤列表，但我们可以展示一个通用示例。 假设我们有一个包含这段代码的复杂系统：
```
Contract System {
    … 
    function calculateSomething() public returns (uint256) {
       if (booleanState) {
           stateSomething = (uint256State1 * uint256State2) / 2**128;
           return stateSomething / uint128State;
       } 
       …
    }
}
```
其中 `boolState`、`uint256State1`、`uint256State2` 和 `stateSomething` 是我们要测试的系统的状态变量。 我们将创建一个model（例如复制、粘贴和修改新合约中的原始代码），其中每个状态变量都转换为一个参数：
```
Contract SystemModel {

    function calculateSomething(bool boolState, uint256 uint256State1, …) public returns (uint256) {
       if (boolState) {
           stateSomething = (uint256State1 * uint256State2) / 2**128;
           return stateSomething / uint128State;
       } 
       …
    }
}
```
此时，我们应该能够在不依赖原始代码库的情况下编译我们的model（所有必要的东西都应该包含在模型中）。 然后，我们可以插入断言来检测返回值何时超过某个阈值。

虽然开发人员或审计人员可能会很想使用这种技术快速创建测试，但在创建model时存在某些缺点：
- 测试的代码可能与我们想要测试的代码大不相同：这可能会引入不真实的问题（误报）或隐藏原始代码中的真实问题（误报）。 在这个例子中，不清楚状态变量是否可以取任意值。
- 如果代码被更改，model将具有有限的价值，因为对原始model的任何修改都会强制重建model，而这应该手动执行。

在任何情况下，都应该警告开发人员他们的代码难以测试，并且应该对其进行重构以避免将来出现这个问题。