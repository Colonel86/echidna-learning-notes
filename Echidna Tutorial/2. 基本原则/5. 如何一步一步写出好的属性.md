## Introduction
在这个简短的教程中，我们将详细介绍使用 Echidna 编写有趣或有用properties的一些想法。 在每一步，我们都会迭代地改进我们的properties。

## A first approach
使用 Echidna 编写的最简单的属性之一是在某个函数预期revert/return时抛出一个断言。

假设我们有一个如下所示的合约接口：
```
interface DeFi {
  ERC20 t;
  function getShares(address user) external returns (uint256)
  function createShares(uint256 val) external returns (uint256)
  function depositShares(uint256 val) external
  function withdrawShares(uint256 val) external
  function transferShares(address to) external
  ...
```
在此示例中，用户可以使用 `depositShares` 存入代币，使用 `createShares` 铸造股票，使用`withdrawShares` 提取股票，使用 `transferShares` 将所有股票转让给另一个用户，并使用 `getShares` 获取任何帐户的股票数量。 我们将从非常基本的属性开始：
```
contract Test {
  DeFi c;
  ERC20 token;

  constructor() {
    c = DeFi(..);
    token.mint(address(this), ...);
  }
  
  function getShares_never_reverts(uint256 val) public {
      (bool b,) = c.call(abi.encodeWithSignature("getShares(address)", address(this)));
      assert(b);
  }

  function depositShares_never_reverts(uint256 val) public {
    if (token.balanceOf(address(this)) >= val) {
        (bool b,) = c.call(abi.encodeWithSignature("depositShares(uint256)", val));
        assert(b);
    }
  }
  
  function withdrawShares_never_reverts(uint256 val) public {
    if (c.getShares(address(this)) >= val) {
        (bool b,) = c.call(abi.encodeWithSignature("withdrawShares(uint256)", val));
        assert(b);
    }
  }
  
  function depositShares_can_revert(uint256 val) public {
    if (token.balanceOf(address(this)) < val) {
        (bool b,) = c.call(abi.encodeWithSignature("depositShares(uint256)", val));
        assert(!b);
    }
  }
  
  function withdrawShares_can_revert(uint256 val) public {
    if (c.getShares(address(this)) < val) {
        (bool b,) = c.call(abi.encodeWithSignature("withdrawShares(uint256)", val));
        assert(!b);
    }
  }
  
}
```
编写完第一个版本的properties后，运行 Echidna 以确保它们按预期工作。 在本教程中，我们将逐步改进它们。 强烈建议在每一步运行fuzzer，以增加检测任何潜在问题的可能性。

也许您认为这些properties级别太低而无用，特别是如果代码在单元测试方面具有良好的覆盖率。 但是您会惊讶地发现，意外的revert/return往往会发现一个复杂而严重的问题。 此外，我们将看到如何改进这些properties以涵盖更复杂的后置条件。

在继续之前，我们将使用 [try/catch](https://docs.soliditylang.org/en/v0.6.0/control-structures.html#try-catch) 改进这些属性。 使用低级调用迫使我们手动对数据进行编码，这很容易出错（错误总是会导致调用revert）。 请注意，这仅在代码库使用 solc 0.6.0 或更高版本时才有效：
```
  ...
  function depositShares_never_reverts(uint256 val) public {
    if (token.balanceOf(address(this)) >= val) {
        try c.depositShares(val) { /* not reverted */ } catch { assert(false); }
    }
  }
  
  function depositShares_can_revert(uint256 val) public {
    if (token.balanceOf(address(this)) < val) {
        try c.depositShares(val) { assert(false); } catch { /* reverted */ }
    }
  }
  ...
  
}
```
## 增强后置条件检查
如果前面的属性通过，这意味着前置条件足够好，但后置条件不是很精确。 避免恢复并不意味着合同处于有效状态。 让我们添加一些基本的前提条件：
```
  ...
  function depositShares_never_reverts(uint256 val) public {
    if (token.balanceOf(address(this)) >= val) {
        try c.depositShares(val) { /* not reverted */ } catch { assert(false); }
        assert(c.getShares(address(this)) > 0);
    }
  }
  
  function withdrawShares_never_reverts(uint256 val) public {
    if (c.getShares(address(this)) >= val) {
        try c.withdrawShares(val) { /* not reverted */ } catch { assert(false); }
        assert(token.balanceOf(address(this)) > 0);
    }
  }
  ...
  
}
```
嗯，每次deposit/withdrawal后获得的shares/tokens的价值，看起来并不容易。 至少我们可以说我们必须得到一些东西，对吧？

## 组合属性
在这个通用示例中，尚不清楚是否有一种方法可以计算在执行deposit/withdraw操作后我们应该收到多少股或代币。 当然，如果我们有这些信息，我们应该使用它。 无论如何，我们在这里可以做的是将这两个属性组合成一个属性，以便能够更准确地检查它的先决条件。
```
  ...
  function deposit_withdraw_shares_never_reverts(uint256 val) public {
    uint256 original_balance = token.balanceOf(address(this)); 
    if (original_balance >= val) {
        try c.depositShares(val) { /* not reverted */ } catch { assert(false); }
        uint256 shares = c.getShares(address(this);
        assert(shares > 0);
        try c.withdrawShares(shares) { /* not reverted */ } catch { assert(false); }
        assert(token.balanceOf(address(this)) == original_balance);
    }
  }
  ...
  
}
```
生成的属性检查表明deposit/withdraw股票的调用永远不会恢复，一旦它们执行，原始代币数量保持不变。 请记住，此属性应考虑费用和任何可容忍的精度损失（例如，当计算需要除法时）。

## 最后的考虑
此示例的两个重要考虑因素：

我们希望 Echidna 将大部分执行时间用于探索合约进行测试。 所以，为了让属性更高效，我们应该避免无事可做的死枝。 这就是为什么我们可以改进 `depositShares_never_reverts` 以使用：
```
function depositShares_never_reverts(uint256 val) public {
    if(token.balanceOf(address(this)) > 0) {
      val = val % token.balanceOf(address(this));
      try c.depositShares(val) { /* not reverted */ } catch { assert(false); }
      assert(c.getShares(address(this)) > 0);
    } else {
      ... // code to test depositing zero tokens
    }
}
```
此外，组合properties并不意味着我们必须删除更简单的属性。 例如，如果我们要编写`withdraw_deposit_shares_never_reverts`，其中我们颠倒操作顺序（取款然后存款，而不是存款然后取款），我们必须确保`c.getShares(address(this))` 是正数 . 一个简单的方法是保留 `depositShares_never_reverts`，因为此代码允许 Echidna 从 `address(this)` 存入代币（否则，这是不可能的）。

## 总结：如何写出好的属性
首先开始编写简单的属性然后改进它们以使其更精确和更易于阅读通常是一个好主意。 在每个步骤中，您都应该运行一个简短的 fuzzing 活动，以确保它们按预期工作，并尝试在smart contracts开发过程中及早发现问题。