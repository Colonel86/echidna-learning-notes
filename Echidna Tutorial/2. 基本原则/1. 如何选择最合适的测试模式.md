# 如何选择最合适的测试模式
由于 Echidna 提供了多种编写properties(属性)的方法，因此开发人员或审计人员经常想知道应该使用哪种测试模式。 我们将回顾每种模式的工作原理，以及它们的优缺点。
## Boolean properties
默认情况下，使用“property”测试模式，它使用称为properties的特殊函数报告失败：

- 测试函数应使用特定前缀命名（例如 `echidna_`）。
- 测试函数不带参数，并且总是返回一个布尔值。
- 任何副作用都将在属性执行结束时`reverted`。
- 如果属性返回 true，则properties通过，如果返回 false 或revert则失败。 作为替代方案，以`echidna_revert_`开头的属性如果返回任何值（真或假）将失败，如果它们恢复则通过。 此伪代码总结了属性的工作原理：

```
function echidna_property() public returns (bool) { // No arguments are required

    // The following statements can trigger a failure if they revert 
    publicFunction(..);
    internalFunction(..);
    contract.function(..);

    // The following statement can trigger a failure depending on the returned value
    return ..;
} // side effects are *not* preserved

function echidna_revert_property() public returns (bool) { // No arguments is required

    // The following statements can *never* trigger a failure
    publicFunction(..);
    internalFunction(..);
    contract.function(..);

    // The following statement will *always* trigger a failure regardless of the value returned
    return ..;
} // side effects are *not* preserved
```
#### 优点：
- 与其他测试方法相比，properties更容易编写和理解。
- 无需担心副作用，因为这些会在属性执行结束时reverted。
  
#### 缺点：
- 由于属性不带参数，因此应使用状态变量添加任何额外的输入。
- 任何revert都将被解释为失败，这并不总是预期的。
- 在执行期间不收集任何覆盖率，因此这些属性应与简单代码一起使用。 对于任何复杂的东西（例如，有大量分支），应该使用其他类型的测试。

#### 建议
当可以通过使用状态变量（内部或公共）轻松计算property并且不需要使用额外参数时，可以使用此模式。

#### Assertions
使用"assertion"测试模式，Echidna 将在以下情况下报告断言违规：

- 在调用 `assert` 期间执行revert。 从技术上讲，如果 Echidna 在目标合约的第一个调用帧中执行失败的断言调用，它将检测到断言失败（因此在大多数情况下，这不包括任何内部事务）。
- 任何contract都会发出 AssertionFailed 事件（带有任意数量的参数）。 这个伪代码总结了assertions是如何工作的：
```
function checkInvariant(..) public { // 支持任意参数

    // 以下语句可以使用 `assert` 触发失败
    assert(..); 
    publicFunction(..);
    internalFunction(..);

    // 以下语句将始终触发失败，即使执行以 revert 结束
    emits AssertionFailure(..);

    // 如果使用 solc 0.8.x 或更高版本，以下语句将*仅*使用 `assert` 触发失败

    // 要确保它适用于旧版本，请使用AssertionFailure(..) event
    anotherContract.function(..);
    
} // 副作用被保留
```
检查断言的函数不需要任何特定的名称，并且像任何其他函数一样执行，因此，如果它们不恢复，它们的副作用会被保留。

#### 优点
- 易于实现，特别是在计算invariant需要任意数量的参数时。
- 在执行这些测试期间收集覆盖率，因此它可以帮助解决新的故障。
- 如果代码库已经包含用于检查invariants的断言，则可以重用它们。

#### 缺点
- 如果要测试的代码已经使用断言进行数据验证，它将无法按预期工作。 例如：
```
function deposit(uint256 tokens) public {
  assert(tokens > 0); // should be strictly positive
  ..
```
开发人员应该避免这样做，而是使用 require ，但如果因为您调用了一些超出您控制范围的合同而无法做到这一点，您可以使用 AssertionFailure 事件。

#### 推荐
如果你的invariant更自然地使用参数来表达，或者它只能在事务中间检查，你应该使用assertions。 assertions的另一个很好的用例是需要检查某些内容以及更改状态的复杂代码。 在以下示例中，我们测试了一些 ERC20 的质押，假设发送者余额中至少有 MINSTAKE 代币。
```
function testStake(uint256 toStake) public {
    uint256 balance = balanceOf(msg.sender);
    toStake = toStake % (balance + 1); 
    if (toStake < MINSTAKE)                             // Pre: 需要最少的股份
      return;
    stake(msg.sender, toStake);                         // Action: 代币质押
    assert(staked(msg.sender) == toStake);              // Post:  质押金额为toStake
    assert(balanceOf(msg.sender) == balance - toStake); // Post: 余额减少
}
```
`testStake` 检查质押的一些invariants，但也确保合约状态得到正确更新（例如，只允许用户至少质押 `MINSTAKE`）。

## Dapptest
使用“dapptest”测试模式，Echidna 将按照 dapptool 和 Foundry 的工作方式使用某些功能报告违规行为：

此模式使用带有一个或多个参数的任何函数名称，如果它们revert将触发失败，除非在一种特殊情况下。 也就是说，如果执行因特殊原因“FOUNDRY::ASSUME”而revert，则测试将通过（这模拟了[假设代工厂作弊代码的工作方式](https://github.com/gakonst/foundry/commit/7dcce93a38345f261d92297abf11fafd6a9e7a35#diff-47207bb2f6cf3c4ac054647e851a98a57286fb9bb37321200f91637262d3eabfR90-R96)）。 这个伪代码总结了 dapptests 的工作原理：

```
function checkDappTest(..) public { // 需要一个或多个参数
    // 以下语句如果revert，则会触发失败
    publicFunction(..);
    internalFunction(..);
    anotherContract.function(..);
    // 下面的语句永远不会触发失败
    require(.., “FOUNDRY::ASSUME”);
}
```
- 实现这些测试的函数不需要任何特定的名称，并且像任何其他函数一样执行，因此，如果它们不恢复，它们的副作用会保留（但通常，这种模式仅用于无状态测试）。
- 该功能不应支付（但将来可能会改变）

#### 优点：
- 易于实现，特别是对于无状态模式。
- 在执行这些测试期间收集覆盖率，因此它可以帮助解决新的故障。
  

#### 缺点：
几乎任何revert都将被解释为失败，这并不总是预期的。 为避免这种情况，您应该使用带有 FOUNDRY::ASSUME 的revert或使用 try/catch。

#### 推荐
如果您正在测试无状态invariants并且代码永远不会意外revert，请使用 dapptest 模式。 避免将它用于状态测试，因为它不是为此而设计的（但是，Echidna 支持它）。

## Stateless vs Stateful
可以在stateful-有状态(默认)或stateless-无状态模式（使用 --seqLen 1）中使用任何这些测试模式。 在stateful模式下，Echidna 将保持每个函数调用之间的状态，并尝试打破invariants。 在stateless，Echidna 将丢弃模糊测试期间的状态变化。 这两种模式存在显着差异。

Stateful更强大，并且可以允许破坏仅在合约达到特定状态时才存在的invariants。
Stateless测试比Stateful测试更容易使用，并且受益于更简单的输入生成。
Stateless测试可以隐藏问题，因为其中一些可能依赖于单个事务中无法访问的一系列操作。
Stateless模式会在每次交易或测试后强制重置 EVM，这通常比每隔一定数量的交易（默认情况下，每 100 笔交易）重置一次状态要慢。

#### 建议
在初学者的使用方面，我们建议开始使用Stateless的 Echidna，并在您对系统的invariants有很好的了解后切换到Stateful。