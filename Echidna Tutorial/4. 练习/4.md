本练习基于教程如何[测试断言](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/assertion-checking.md)。

## 目标合约
```
contract Ownership{
    address owner = msg.sender;
    function Owner() public{
         owner = msg.sender;
     }
     modifier isOwner(){
         require(owner == msg.sender);
         _;
      }
   }

  contract Pausable is Ownership{
     bool is_paused;
     modifier ifNotPaused(){
              require(!is_paused);
              _;
      }

      function paused() isOwner public{
          is_paused = true;
      }

      function resume() isOwner public{
          is_paused = false;
      }
   }

   contract Token is Pausable{
      mapping(address => uint) public balances;
      function transfer(address to, uint value) ifNotPaused public{
           balances[msg.sender] -= value;
           balances[to] += value;
       }
    }
```

目标
添加asserts以确保调用 transfer 后：

- `msg.sender` 必须有其初始余额或更少。
- `to` 必须有其初始余额或更多。

一旦 Echidna 找到错误，修复问题，然后用 Echidna 重新尝试您的断言。

这个练习类似于第一个练习，但使用assertions而不是显式属性。
但是，在本练习中，修改原始代币合约（exercises/exercise4/token.sol）更容易。

```
echidna-test ./contracts/exercises/exercise4/TokenTest.sol --contract TokenTest --config  ./contracts/exercises/exercise4/config.yaml
```
注意在0.8.x版本由于内置了safamath，导致始终成功

一下结果是在0.4.26版本下
```
assertion in transfer(address,uint256): FAILED! with ErrorUnrecognizedOpcode 

Call sequence:
1.transfer(0x0,1)  
```